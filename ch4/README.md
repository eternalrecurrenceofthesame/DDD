## 4.1 JPA 를 이용한 리포지토리 구현

리포지토리 인터페이스는 애그리거트 루트를 기준으로 만들어진다. 리포지토리 인터페이스는 도메인 영역에 속하는 고수준 모듈, 리포지토리 구현체는 

인프라 영역에 속하는 저수준 모듈로 설계하자! 

Tip 삭제 요구사항이 있더라도 실제 삭제 기능을 만들지 않고 화면에서 보여줄지 여부를 결정하는 방식으로 만들자. 삭제 후 일정 기간 데이터를 보관해야 할 때도 있기 때문이다.


## 4.2 스프링 데이터 JPA 를 통한 리포지터리 구현 

## 4.3 매핑 구현 

애그리거트와 JPA 매핑을 위한 기본 규칙

* 애그리거트 루트는 엔티티이므로 @Entity 매핑

한 테이블에 엔티티와 밸류 데이터가 같이 있다면

* 밸류는 @Embeddable (값 타입을 정의하는 곳) 로 매핑

* 밸류 타입 프로퍼티는 @Embedded (값 타입을 사용하는 곳) 로 매핑

JPA 에서 @Entity, @Embeddable 로 클래스를 매핑하려면 **기본 생성자**를 제공해야 한다. DB 에서 데이터를 읽어와 매핑된 객체를 

생성할 때 기본 생성자를 사용해서 객체를 생성하기 때문 값 타입은 불변 객체로 만들어야 한다, 다른 곳에서 사용하지 못하도록 프로텍티드 생성자를 만들어주자.

Tip 

> 엔티티 프로퍼티 접근법@Access(AccessType.PROPERTY) 을 사용하게 되면 get/set 메서드를 열어야 됨 get/set 메서드를 추가하면 
>
> 도메인의 의도가 사라지고, 내부의 데이터를 외부에서 변경할 수 있기 때문에 캡슐화를 깨는 원인이 된다.
>
> set 을 사용하는 경우는 private 으로 클래스 내부 변경만을 목적으로 사용한다, 그리고 set 메서드 대신 의도가 잘 드러나는 메서드 이름을 사용해야 한다.
>
> ex) setShippingInfo() 보다 changeShippingInfo() 를 사용해서 배송지를 변경한다는 의미를 명확하게 표현
