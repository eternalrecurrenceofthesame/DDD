## 1.1 도메인이란?

소프트웨어로 해결하고자 하는 문제 영역, 하나의 도메인은 하위 도메인으로 나뉜다. 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공하기도 한다.

도메인을 위한 기능을 직접 제공하지 않고 외부 영역과 연동할 수도 있다. (배송 추적 시스템, 결제)

## 1.2 도메인 전문가와 개발자 간 지식 공유

도메인 전문가, 관계자, 개발자 간의 직접적인 소통을 통해서 요구 사항을 올바르게 이해해야 한다. 전문가, 관계자가 요구하는 것이 정확하게 표현되지 않을 때도 있다.

이런 경우 실제로 원하는 것이 무엇인지 생각하고 전문가와 대화를 통해서 진짜로 원하는 것을 찾아야한다. 26p

## 1.3 도메인 모델

다양한 기법(UML, 클래스 다이어그램 등등)을 사용해서 도메인 모델을 만들고 관계자들과 공유할 수 있다. 개념적 모델을 물리적 모델로 모델링 할 때도 큰 틀에서 방향성을 잡을 수 있다.

처음부터 완벽한 개념모델을 만들 수는 없다. 프로젝트 초기에는 도메인에 대한 전체 윤곽을 이해하는 데 집중하고 구현 과정에서 개념 모델을 발전시켜나가자.

도메인은 다양한 하위 도메인으로 나뉘는데 각 하위 도메인마다 의도하는 것이 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다.

도메인에 따라 용어의 의미가 결정되므로 여러 하위 도메인을 하나의 다이어그램으로 모델링하면 안 된다. 

ex) 카탈로그로 보여주는 상품의 의미와 배송 도메인에서의 상품의 의미는 다르다.

## 1.4 도메인 모델 패턴

일반적인 애플리케이션 아키텍처가 구성하는 네 개의 영역 

* 표현 - 사용자 요청 처리, 화면 
* 응용 - 도메인 계층을 조합해서 기능 실행
* 도메인 - 도메인 규칙 구현
* 인프라스럭처 - DB, 메시징, 외부 시스템과 연동, 프레임워크 93p

도메인 규칙을 객체지향적으로 구현하는 것을 도메인 모델 패턴이라고 한다. 도메인 계층은 도메인의 핵심 규칙을 구현한다.

예제 - Order.class

## 1.5 도메인 모델 도출

도메인 모델링의 기본은 (핵심 구성 요소, 규칙, 기능)을 찾는것 이 과정은 ***요구사항***에서 출발한다. 

예제 - Order , OrderLine, OrderState, ShippingInfo

문서화를 통해서 소프트웨어의 전반적인 기능과 의도를 파악할 수 있게 해야한다. 코드를 작성할 때도 도메인 지식이 잘 묻어나도록 작성해야 한다. 41p

## 1.6 엔티티와 밸류

도출한 모델은 크게 엔티티와 밸류로 구분할 수 있다. 앞서 요구사항 분석 과정에서 만든 모델에 엔티티도 존재하고 밸류도 존재한다.

엔티티의 가장 큰 특징은 식별자를 가진다는 것이다. 

* 엔티티의 식별자 생성
    
    * 특정 규칙에 따른 생성
    
    * UUID, Nano ID // UUID uuid = UUID.randomUUID(); String str = uuid.toString(); // 나노 ID 45p
   
    * 직접 입력
  
    * 일련번호 사용(시퀀스, DB)  // 보편적인 방법 데이터베이스에서 PK 값을 생성하게 하고 받아오기 
    
    
* 밸류 타입이란?
```
ShippingInfo class
  private String reciverName;        // 받는 사람
  private String reciverPhoneNumber;
  
  pirvate String shippingAddress1;    // 주소 
  private String shippingAddress2;
  private String shippingZipcode;
```

배송정보 클래스에는 받는 사람과 주소 두 종류의 필드가 있음 이때 각각의 필드를 개념적으로 

하나의 클래스로 표현하는 것을 밸류 타입이라고 한다. (깔끔하고 명확해짐) 참고 - ShippingInfo.class 

```
public class Receiver {
private String name;
private String phoneNumber;
}
```

밸류 타입이 꼭 두 개 이상의 데이터를 가져야 하는 것은 아니다. 의미를 명확하게 표현하기 위해 밸류 타입을 사용하는 경우도 있다.

OrderLine 에서 price, amount 는 int 를 사용하고 있지만 돈을 의미하는 필드이다. 돈을 의미하는 Money.class 를 만들어서 자료형으로 사용하면

의미가 더 명확해진다.

밸류 타입은 밸류 타입을 위한 기능을 추가할 수 있다. Money 타입에 돈 계산을 위한 기능 추가해서 돈 계산이라는 의미로 코드 작성 가능!

밸류 타입은 불변 객체로 생성해야 한다. 값 타입의 필드 값들을 기본 타입으로 사용하면 서로 공유되지 않지만, 값 타입이 인스턴스로 

만들어지면 필드 값이 공유될 수 있기 때문에 생성자를 통해서 생성하고 set 을 막아서 값을 변경할 수 없게 하여 불변 객체로 만든다.

https://github.com/eternalrecurrenceofthesame/JPA/tree/main/JPA-basic 참고 

```
Money price = ...;
Money quantity = ...;
OrderLine line = new OrderLine(product, price, quantity); // 주문 상세의 price 값을 함부로 바꾸면 안됨!

price.set (x)

```

주문의 가격을 함부로 바꿀 수 없게 하기 위해 밸류 타입 Money 를 불변 객체로 만들고, 밸류 객체의 데이터 변경시 기존 데이터의 변경이 아닌

변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 add 메서드를 만들어준다! 50p

```
public class Order{
private OrderNo id;
}

```
엔티티의 식별자를 밸류타입으로 만들면 의도를 명확하게 전달할 수 있다.

OrderNo 대신 String 타입을 사용하면 id 라는 이름만으로 해당 필드가 주문 번호인지 알 수 없음 

#### + 도메인 모델에 set 메서드 넣지 않기!

set 을 이용해서 값을 변경하게 되면 단순히 값의 상태만 변경한다는 의미를 나타내기 때문에 변경과 관련된 **도메인 지식**이 코드에서 사라지게 된다.

```
setShippinInfo(){} <- 단순한 배송지 값을 설정한다는 의미

changeShippingInfo(){} <- 설정된 배송지 정보를 새로 변경한다는 의미! 명확함!
```

set 의 또 다른 문제는 도메인 객체를 생성할 떄 온전하지 않은 상태가 될 수 있다는 것임 Order 를 만들 때 애초에 생성자 주입을 사용하면

값을 누락할 일이 없음 하지만 Order 객체를 만들고 set 을 하나하나 해주면 값을 누락할 수가 있다. 

생성자로 필요한 값을 모두 받고,  생성자를 호출하는 시점에 매개변수의 데이터가 올바른지 검사할 수 있다.

```
public Order(Orderer orderer, ...){
setOrderer(orderer);
...}

private void setOrderer(Orderer orderere){
if(orderer == null) throw new IllegalArgumentExecption("no orderer"); // 생성자 호출시 null 체크 
this.orderer = orderer;
}
```
이 코드의 set 메서드는 private 으로 만들었기 때문에 클래스 내부의 데이터를 변경할 목적으로만 사용할 수 있음! 외부에서 데이터 변경을 목적으로 사용 불가!


#### ++ DTO 의 get/set 메서드

DTO 는 엔티티를 알고 있는다던지, get/set 메서드를 사용해도 되지만 프레임워크가 DI 기능을 제공한다면 set 메서드 대신 private 필드에 값을 할당 받아서 사용할 수도 있다!


## 1.7 도메인 용어와 유비쿼터스 언어

전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화,문서,도메인 모델, 코드 ,테스트 등 모든 곳에서 같은 용어를 사용하자.

이렇게 하면 소통 과정에서 발생하는 용어의 모호함을 줄일 수 있고 도메인과 코드 사이에서의 불필요한 해석 과정을 줄일 수 있다. 영어의 뉘앙스 의미를 명확하게 아는 것도 중요
