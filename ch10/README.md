## 10.1 시스템 간 강결합 문제

쇼핑몰에서 구매를 취소하면 환불 처리를 해야 한다. 환불 처리를 도메인 서비스로 만들고 도메인 객체에서 도메인 서비스를 이용해 직접 처리하거나 

응용 서비스에서 도메인 서비스를 이용해서 환불 처리를 할 수 있다.

* 도메인에서 도메인 서비스를 직접 처리하는 경우

```
public class Order{

public void cancel(RefundService refundService){

verifyNotYetShipped();
this.state = OrderState.CANCELED; // 주문 관련 로직

this.refundStatus = Status.REFUND_STARTED; // 결제 로직
try{
refundSvc.refund(getPaymendId());
this.refundStatus = Status.REFUND_COMPLETED;

} catch(Exception ex){
...
}
}
```

도메인 객체에서 도메인 서비스를 직접 이용하는 경우 주문 로직과 결제 로직이 서로 섞이게 된다.

환불 기능이 바뀌게 되면 Order 도 같이 영향을 받게되고 

환불 취소기능에 환불 취소 메시지 전송 같은 부가 기능이 추가될수록 로직이 꼬이게되고 더 복잡하게 된다.


* 응용 서비스에서 도메인 서비스를 직접 처리하는 경우

```
public class CancelOrderService{
  private RefundService refundService;
  
  @Transactional
  public void cancel(OrderNo orderNo){
  
  Order order = findOrder(orderNo);
  order.cancel();
  
  order.refundStarted();
  
  try{
  refundService.refund(order.getPaymendId());
  order.refundCompleted();
  }catch(Exception ex){...}

}
```

트랜잭션이 문제될 수 있다. 주문을 찾고 주문을 취소하면서 환불 도메인 서비스를 이용해서 환불을 호출했는데

환불 도메인 서비스에서 오류가 발생한다면 주문 취소 서비스를 롤백하거나 주문을 취소 상태로 변경하고 환불만 

나중에 다시 시도해야할 수 있다.

환불 요청에 대한 대기시간이 길어진다면 외부 서비스로 인한 성능 문제까지 발생한다.


## 10.2 이벤트 개요

앞서 살펴본 강 결합 문제를 해결할 수 있는 것으로 이벤트를 사용하는 방법이 있다.

이벤트란? 과거에 벌어진 어떤 것을 의미한다. '암호 변경 했음 이벤트', '주문을 취소 했음 이벤트' 등등

~할 때, ~가 발생하면, 만약 ~하면 과 같은 요구 사항은 도메인의 상태 변경과 관련된 경우가 많고 이런 요구 사항을

이벤트로 구현할 수 있다.

이벤트는 네 개의 구성요소로 구성된다.

이벤트 생성 주체 -> 이벤트 디스패처(퍼블리셔) -> 이벤트 핸들러(구독자)

이벤트 생성주체가 이벤트를 생성하고 이벤트 디스패처가 중간에서 이벤트를 받고 이벤트 핸들러를 호출해서 이벤트를 전달한다.

> 이벤트 구성 요소
> * 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
> * 이벤트 발생 시간
> * 추가 데이터: 주문 번호, 신규 배송지 정보 등 이벤트 관련 정보 

```
이벤트를 위한 클래스

public class ShippingInfoChangedEvent { // 배송지를 변경했음 이벤트, 이벤트는 현재 기준으로 과거에 벌어진 일이다! 과거 시제 사용

  private String orderNumber;
  private long timestamp; // 발생 시간
  private ShippingInfo new ShippingInfo;

}
```

```
public class Order{ // 이벤트 발행 주체인 Order 애그리거트 

  public void changeShippingInfo(ShippingInfo newShippingInfo){
  verifyNotYetShipped();
  setShippinginfo(newShippingInfo);
  Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo)); // 디스패처를 통한 이벤트 전파 기능 제공
  }
}
```

```
핸들러는 이벤트에 담긴 내용을 이용해 원하는 기능을 수행한다.

public class ShippingInfoChangedHandler { // 핸들러는 보통 도메인의 인프라에 속한다

  @EventListner(ShippingInfoChangedEvent.class)
  public void handle(ShippingInfoChangedEvent evt){
    shippingInfoSynchronizer.sync(
    evt.getOrderNumber(),
    evt.getNewShippingInfo());
  
  }
}

이벤트는 핸들러에서 처리하는 스펙에 맞게 보내야한다. 핸들러에서 처리할 수 없는 데이터를 전송하면 관련 API 를 호출하거나

DB 에서 데이터를 직접 호출해야한다. 또한 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없다.
```

이벤트는 트리거와 시스템 간 데이터 동기화의 역할을 수행한다. 도메인 상태가 변경되면 후처리를 위한 이벤트를 발행하고 

이벤트 구독자는 전달된 이벤트를 통해서 변경된 데이터를 동기화 한다.

이벤트를 사용함으로써 애그리거트에 다른 도메인 로직이 섞이는 것을 방지할 수 있다.


## 10.3 이벤트, 핸들러, 디스패처 구현

응용 서비스에서 Order cancel 메서드를 호출한다. Order 는 주문을 취소 상태로 바꾸고 이벤트를 생성해서 이벤트 디스페처에 전달한다.

주문에서는 주문과 관련된 취소 로직만 수행하고 환불은 이벤트로 처리해서 시스템간 강 결합 문제를 해결할 수 있다.

이벤트 디스페처에서는 이벤트를 구독하고 있는 핸들러를 호출하고 핸들러에서 이벤트 데이터로 외부 도메인 서비스의 환불 로직을 호출한다. 

order.domain, common.event 패키지 참고

동기 이벤트 순서 : Order -> OrderCanceledEvent 생성 -> Events 디스페처 이벤트 출판 ->  OrderCanceledEventHandler

## 10.4 동기 이벤트 처리 문제

이벤트를 구현해서 시스템 간 강 결합 문제는 해결했지만 문제가 남아 있다. 응용 서비스에서 주문을 취소 환불 로직이 호출된다.

응용 서비스는 외부 환불 서비스에 의존하고 있기 때문에 환불 서비스에서 응답이 느려지면 응용 서비스의 성능도 저하된다

또 환불이 실패하는 경우 트랜잭션이 문제가 될 수 있다. 환불에 실패하고 트랜잭션을 롤백하면 주문 취소 자체가 사라지게 된다.

주문 취소를 처리하고 환불만 재처리하거나 수동으로 처리하는 방법도 고려할 수 있다.

외부 시스템과의 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제를 해소하기 위해서 

이벤트를 비동기로 처리하거나 이벤트와 트랜잭션을 연계하는 방법을 사용할 수 있다.

## 10.5 비동기 이벤트 처리

* 로컬 핸들러 비동기 실행

이벤트 핸들러를 별도 스레드로 실행하게 해서 비동기로 실행할 수 있다. @EnableAsync, @Async 애노테이션 사용.

* 메시지 큐를 이용한 비동기 처리

카프카, 래빗MQ 를 이용한 비동기 처리 

이벤트를 발행하고 메시징 큐에 이벤트를 보낸다, 메시지 큐는 이벤트를 메시지 리스너에 전달하고 메시지 리스너는 알맞은

이벤트 핸들러를 이용해서 이벤트를 처리한다. 이때 이벤트를 메시지 큐에 저장하는 과정과, 메시지 큐에서 이벤트를 읽어와

처리하는 과정은 별도 스레드나 프로세스로 처리된다.

글로벌 트랜잭션을 이용해서 도메인 변경사항을 DB 에 저장하고 메시지 큐에 발행한 메시지를 저장하는 과정을 하나로 묶을 수도 있다.

글로벌 트랜잭션 사용시 안전한게 메시지를 저장할 수 있지만 글로벌 트랜잭션으로 인해 성능 저하가 일어난다.

또 글로벌 트랜잭션을 지원하지 않는 메시지 시스템도 있음.


* 이벤트 저장소를 이용한 비동기 처리

도메인에서 이벤트를 발행하고 이벤트 디스패처를 통해 직접 이벤트 핸들러에 전달하는 것이 아닌 로컬 핸들러를 통해서 로컬 저장소에

이벤트를 저장하고 API 나 포워드를 통해서 로컬 저장소에 있는 이벤트 데이터를 제공해줄 수 있다.

```
## API 방식을 사용하는 경우

* EventEntry - 이벤트 저장소에 저장할 데이터

* common.event.EventStoreHandler - 도메인에서 이벤트 디스패처를 통해 호출하는 저장 로컬 핸들러 

* EventStore - 로컬 저장소. JdbcTemplate 을 이용해서 이벤트를 저장소에 저장한다. 이벤트는 과거에 발생한 사건이기 때문에

데이터가 변경되지 않는다 이벤트 저장소는 이벤트를 추가하는 기능과 조회하는 기능만 제공한다.

* EventApi 

클라이언트는 일정한 간격으로 EventApi 에 값을 요청한다 이때 offset, limit 정보를 보내는데 

offset 은 클라이언트에서 관리하는 이벤트 세이브 포인트가 되고 limit 은 요청하는 이벤트의 개수가 된다. 


도메인은 계속해서 이벤트를 발행하고 로컬 저장소에 이벤트가 저장된다. 클라이언트는 일정한 간격으로 이벤트를 요청하는데

이벤트 요청에대한 관리는 API 통신을 사용할 경우 클라이언트에서 한다. 

도메인은 도메인대로 도메인 로직을 수행하고 클라이언트는 필요한 이벤트를 순차적으로 처리할 수 있게 된다.

클라이언트에서 이벤트 처리에 오류가 발생하더라도 실패한 이벤트부터 읽어와서 이벤트를 처리를 재시도 할 수 있다! 


순서

Order -> Events 디스패처 이벤트 출판 -> EventStoreHandler 로컬 핸들러 -> JdbcEventStore 로컬 저장소 호출 
                                                                         <- EventAPI <- 클라이언트의 이벤트 핸들러 호출 조회


```
     
```
## 포워더 구현

포워더는 일정 주기로 EventStore 에서 이벤트를 읽어와 이벤트 핸들러에 전달해 준다.

API 와 마찬가지로 마지막에 읽은 값을 기억하고 마지막에 처리한 offset 부터 이벤트를 가져오면 된다.

integration 참고 
```



Tip MySQL 자동 증가 칼럼 주의 사항

자동 칼럼 증가를 이용해서 ID 값이 데이터베이스에 커밋되기 전에 조회를 하면 ID 값이 조회되지 않을 수도 있다.

이런 누락 문제가 발생하지 않도록 하려면 트랜잭션 격리 레벨을 높이거나 데이터 조회 시점과 최대 ID가 증가하는 시점에 차이를 둬야 한다.

CDC(Change Data Capture)를 사용하는 방법도 있다.


## 10.6 이벤트 적용 시 추가 고려 사항

* 이벤트 소스를 EventEntry 에 추가할 것인가?

Order 가 발생시킨 이벤트만 조회하기 처럼 특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현하려면 이벤트에 발생 주체 정보를 추가해야 한다.

* 포워더에서 전송 실패를 얼마나 허용할 것인가?

포워더는 이벤트 전송 실패시 실패한 이벤트를 다시 반복해서 읽어오게 된다. 특정 이벤트에서 계속 전송을 실패한다면?

재 전송 횟수에 제한을 두고 해당 이벤트 생략 후 다음 이벤트로 넘어가야 한다. 또는 생략한 이벤트를 DB 나 메시지 큐에 저장해둘 수 있다.

* 이벤트 손실에 대해

이벤트 저장소를 사용하는 방식은 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션이 성공하면 이벤트가 저장소에 

보관된다는 것은 보장된다.

반면 로컬 핸들러를 이용해서 이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실하게 된다 ??

이벤트 저장소까지 저장되는 과정이 한 트랜잭션에서 실시되는데 처리에 실패하면 전부 롤백된다는 것을 의미하는듯 ??

* 이벤트 순서

이벤트 저장소를 사용하면 이벤트를 순서대로 저장하고 그 순서대로 이벤트 목록을 제공하는 반면 메시징 시스템은

사용 기술에 따라 이벤트 발생 순서와 메시지 전달 순서가 다를 수 있다.

* 이벤트 재처리

마지막에 처리한 이벤트를 기억해두고 동일한 이벤트가 다시 요청되면 해당 이벤트를 처리하지 않고 무시할 수 있다.

ex) 이벤트 도착시 이메일을 발송한다면 동일한 이벤트 아이디가 다시 들어 왔을 때 이메일을 발송하지 않게끔 구현 

멱등성이란? 연산을 여러 번 적용해도 결과가 달라지지 않는 성질을 의미한다. 멱등성을 가지면 중복을 거를 수 있다.


#### + 이벤트 처리와 DB 트랜잭션 고려

* 이벤트를 동기로 처리할 때

외부 시스템을 호출해서 결제를 취소하고 응용 서비스에서 리턴값으로 DB 를 업데이트 할 때 실패한다면?

결제는 취소됐는데 DB 에는 주문이 취소되지 않은 상태가 된다.

* 이벤트를 비동기로 처리할 때 

이벤트 저장소에 이벤트를 저장하고 결제 취소 API 를 비동기로 호출했는데 실패한다면 주문은 취소가 되지만

결제는 취소되지 않은 상태로 남게 된다.


결론은 이벤트 처리를 **동기로하든 비동기로하든 이벤트 처리의 실패와 트랜잭션 실패를 고려해야 한다는 의미**

트랜잭션 실패와 이벤트 처리 실패를 모두 고려하면 복잡해지므로 경우의 수를 줄이면 도움이 된다.

트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것

```
@TransactionalEventListner(
 classess = OrderCanceledEvent.class,
 phase = TransactionPhase.AFTER_COMMIT
 )
 
 public void handle(OrderCanceledEvent event){
 refundService.refund(event.getOrderNumber());
 }
```

* 이벤트 처리를 동기로 할 때

이 값을 지정하면 스프링은 트랜잭션 커밋에 성공한 뒤에 핸들러 메서드를 실행한다. 이 기능을  사용하면 이벤트 핸들러를 실행했는데

트랜잭션이 롤백 되는 상황은 발생하지 않는다.

* 이벤트 처리를 비동기로 할 때

이벤트 발생 코드와 이벤트 저장 처리를 한 트랜잭션으로 처리하면 된다. 이렇게하면 트랜잭션이 성공할 때만 이벤트가 DB 에 저장되고

트랜잭션은 실패했는데 이벤트 핸들러가 실행되는 상황은 발생하지 않는다.


트랜잭션이 성공할 때만 이벤트 핸들러를 실행하게 함으로써 이벤트 처리 이전의 상황은 신경쓰지 않아도 되고 이벤트 처리 실패만 고민하면 된다.

이벤트 특성에 따라 재처리 방식을 결정하자.









