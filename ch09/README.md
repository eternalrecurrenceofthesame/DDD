## 9.1 도메인 모델과 경계

도메인 규칙과 요구사항에 따라서 하위 도메인 모델이 만들어지고 유사하거나 동일한 라이프 사이클을 가지는 모델들이 모여서 애그리거트가 된다.

도메인은 여러 하위 도메인으로 구분되며 완전한 하나의 도메인 모델로 만들어지지 않는다.

하나의 도메인 모델로 만들어지지 않는다는 것은 도메인은 상황에 따라서 다른 의미를 가질 수 있다는 것이다. 

```
예를 들어 상품이라는 모델이 있을 때 카탈로그에서의 상품과, 재고 관리에서의 상품, 주문에서의 상품,
배송에서의 상품은 이름만 같지 실제로 의미하는 것이 다르다.

카탈로그에서의 상품은 상품 이미지, 상품명, 상품 가격, 옵션 목록, 상세 설명과 같은 상품 정보 위주라면,
재고 관리에서는 실존하는 개별 객체를 추적하기 위한 목적으로 상품을 사용하므로 

카탈로그에서는 물리적으로 한 개의 상품이되고 재고 관리에서는 여러 개의 상품이 존재할 수 있게 된다. 

논리적으로 같은 존재 처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다. 회원 도메인에서는 회원이라고 부르지만,
주문 도메인에서는 회원이 주문자가 되고 배송 도메인에서는 보내는 사람으로 사용된다.
```

위 예시 처럼 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위

도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다. 

## 9.2 바운디드 컨텍스트

바운디드 컨텍스트는 각 애그리거트의 하위 모델들별 경계를 결정한다. 논리적으로 한 개의 도메인을 가지게 되며 앞서 말한 용어의 

사용에 따라서 바운디드 컨텍스트가 구분된다.

주문 애그리거트에서의 Orderer 와 회원 애그리거트의 Member 가 바운디드 컨텍스트별로 구분되는 예시이다.

애그리거트 하위 도메인을 여러 개의 바운디드 컨텍스트로 구분할 수 도 있고, 규모가 작다면 하위 도메인 모델을 모아서 하나의 컨텍스트로 묶을 수도 있다 279p

(도메인 내부에서 여러 개의 바운디드 컨텍스트로 구분하거나, 도메인 모델 전체를 하나의 컨텍스트로 묶거나 ) 

이때 주의할 점은 애그리거트 하위 도메인 모델을 섞어버리면 안 된다는 것이다. 애그리거트를 하나로 합치면 안 된다.

> 각 도메인 모델별 컨텍스트 구분 예시 280p
>
>* 회원 바운디드 컨텍스트 - Member<root>
>
>* 주문 바운디드 컨텍스트 - Orderer<value>  
>  
>* 카탈로그 바운디드 컨텍스트 - Product<root> , Category<root>
>
>  (용어를 명확하게 구분하지 못한 경우 두 개의 하위 도메인이 하나의 바운디드 컨텍스트가 되기도 한다.)
>  
>* 재고 바운디드 컨텍스트 - Product<root>

## 9.3 바운디드 컨텍스트 구현
  
바운디드 컨텍스트별로 하위 도메인을 구분한다고해서 바운디드 컨텍스트가 도메인 모델만 가지고 있는 것은 아니다.
  
주문 바운디드 컨텍스트를 구현한다면 (표현, 응용, 도메인, 인프라) 의 모든 요소가 다 들어가게 된다.

모든 바운디드 컨텍스트를 DDD 로 구현하지 않아도 된다.

간단한 리뷰 같은 경우 복잡한 도메인 로직이 필요 없기 때문에(표현, 서비스, DAO) 순으로 구현해도 된다.
  
CQRS 를 이용해서 한 바운디드 컨텍스트에서 두 가지 방식을 혼합해서 사용할 수도 있다.

도메인 로직을 실행해야하는 부분은 DDD 를 사용하고, 간단한 조회같은 경우 서비스에서 바로 DAO 를 호출하면 된다. 283p

두 개의 바운디드 컨텍스트를 조합해서 사용해야 할 수도 있다. 상품 상세 화면은 카탈로그 컨텍스트와 리뷰 컨텍스트를 조합해서 사용하는데
  
UI 서버를 파사드처럼 이용해서 한번에 모아서 값을 보여줄 수도 있고 각각 따로따로 호출해서 보여줄 수도 있다. 283P
  
## 9.4 바운디드 컨텍스트 간 통합
  
온라인 쇼핑 사이트에서 매출 증대를 위해 카탈로그 하위 도메인에 추천 상품 기능을 도입하기로 한다면 바운디드 컨텍스트간 통합이 발생할 수 있다.

(카탈로그 하위 상품 도메인에 추천 상품 도메인 서비스가 추가되는 경우 286 p)

외부 추천 시스템(바운디드 컨텍스트) 으로부터 추천에 관한 도메인 정보를 읽어오는 것을 가정한다. 즉 외부 바운디드 컨텍스트와의 통합 

카탈로그 시스템이 추천 시스템으로부터 추천 데이터를 받아올 때 카탈로그에서 추천 도메인 모델을 사용하기보다는 카탈로그 도메인 모델을
  
사용해서 도메인 서비스를 만들고 받아온 값을 응용 서비스에서 처리한다.
  
  ```
  // 상품 추천 기능을 표현하는 도메인 서비스
  public interface ProductRecommendationService{
    List<Product> getRecommendationOf(ProductId id); // 상품 추천에서 받은 추천 상품 아이디.
  }
  
  카탈로그 관점에서 도메인 서비스를 만들고 인프라에서 외부 상품 추천 시스템 기능 모듈과 통신을 수행한다. 286p
  ```
  ```
  infra 구현체
  
  public class RecSystemClient implements ProductRecommendationService{
  
  private ProductRepository productRepository; // ProductRepository 에 의존.
  
  @Override
  private List<Product> getRecommendationsOf(ProductId id){
  List<RecommendationItem> items = getRecItems(id.getValue());
                          return toProducts(items);
  }
  
  private List<RecommendationItem> getRecItems(String itemId){
  
  //externalRecClient 를 외부 추천 시스템을 위한 클라이언트라고 가정한다. 추천 시스템 관리 모듈
  return externalRecClient.getRecs(itemId); 
  }

  // 카탈로그 바운디드 컨텍스트에서 영향을 받지 않게 상품 모델로 변환한다. 
  private List<Product> toProducts(List<RecommendationItem> items){
  return items.stream().map(item -> toProductId(item.getItemId()).map(prodId -> productRepository.findById(prodId))
              .collect(toList());
  
  private ProductId toProductId(String itemId){
    return new ProductId(itemId);
  }}
  
  
  응용 서비스에서 카탈로그의 상품 아이디를 이용해서 외부 추천 시스템의 추천 상품 로직을 조회한다.
  추천 상품의 아이디 값으로 관련 추천 상품들을 ProductRepository 에서 조회하고 추천 상품 목록을 반환하는 구조.
  
  (OrderServiceImpl, catalog 패키지 참고)
  ```
  
  위 예시처럼 외부 추천 시스템을 통해 REST API 를 호출하는 것은 두 바운디드 컨텍스트를 직접 통합하는 방법이다.
  
  직접 통합 대신 간접 통합 방식으로 메시지 큐를 이용하는 방식이 있다.
  
  카탈로그 바운디드 컨텍스트에서 추천 시스템이 요구하는 사용자 활동이력을 메시지 큐에 추가, 추천 바운디드 컨텍스트는
  
  큐에서 이력 메시지를 읽어와 추천을 계산하는 데 사용한다.
  
  어떤 도메인 관점에서 모델을 사용하느냐에 따라 두 바운디드 컨텍스트의 구현 코드가 달라지게 된다.
  
  카탈로그 도메인 관점에서 큐에 저장할 메시지를 생성하면 카탈로그 시스템의 연동 코드는 카탈로그 기준의 데이터를 그대로 
  
  메시지 큐에 저장한다.
  
  ## 9.5 바운디드 컨텍스트 간 관계
  
  바운디드 컨텍스트는 어떤 식으로든 연결된다. REST API 통신을 하는 경우 호출하는 카탈로그(하류) 쪽이 고객이 되고
  
  데이터를 제공하는 추천(상류) 쪽이 공급자가 된다. 하류가 상류에 의존. **공급자와 고객의 상호 협력은 필수적이다.**
  
  ```
  상류 컴포넌트는 보통 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다.
  상류 팀의 고객인 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구 사항을 수용할 수 있는 API 를 만들고
  
  이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있는데 이것을 공개 호스트 서비스라고 한다.
  상류 컴포넌트 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다.
  
  이때 주의할 점은 고객 입장에서 공급자가 제공하는 도메인 모델에 의해 의존관계 형성될 수 있다는 것이다.
  이를 보호해주는 완충 지대가 infra 에 구현한 RecSystemClient 인프라 구현체이다. 
  
  인프라 구현체에서는 API 통신으로 요청한 값을 고객 바운디드 컨텍스트 모델이 영향을 받지 않게 변환해준다. 
  ```
  
  ```
  두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다 이런 경우 같은 모델을 사용함으로써 모델을 중복해서
  만드는 것을 막아준다. 이렇게 두 팀이 공유하는 모델을 공유 커널이라고 부른다.
  
  ex) 운영자를 위한 주문 관리도구 개발팀에서 사용하는 주문과, 고객을 위한 주문 서비스에서 사용하는 주문
 
  공유 커널을 사용하면 중복을 줄여주는 장점도 있지만 공유 커널을 임의로 변경하지 않아야 한다.
  ```
  ```
  독립 방식이란 두 바운디드 컨텍스트를 서로 통합하지 않느 것을 의미한다.
  바운디드 컨텍스트에서 값이 변경되었을 때 외부 시스템에 직접 수동으로 값을 변경하는 경우.
   ```
  
## 9.6 컨텍스트 맵                                        
                                          
개별 바운디드 컨텍스트를 모아서 전체적인 컨텍스트 맵을 만들 수 있다 이때 주요 애그리거트를 함께 표시하면 모델 관곅가 더 명확해진다. 
  
 ACL(안티 코럽션 계층이라는 뜻)
